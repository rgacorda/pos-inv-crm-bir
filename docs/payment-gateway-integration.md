# Physical Card Terminal Integration Guide (Philippines)

## Overview

This guide covers integrating **physical card terminals** (chip readers, card swipers, contactless) into your POS system for in-person transactions at the point of sale. This covers EMV chip reading, magnetic stripe swiping, and NFC/contactless payments for Philippine retail businesses.

---

## üè¶ Card Terminal Providers in the Philippines

### 1. **BancNet** (Recommended for Local Cards)

**Why BancNet:**

```yaml
‚úÖ Largest ATM network in Philippines
‚úÖ Accepts all local debit cards
‚úÖ Direct connection to Philippine banks
‚úÖ Lower fees for local cards
‚úÖ Wide acceptance
‚úÖ Trusted brand
```

**Supported Cards:**

- BancNet debit cards (all PH banks)
- Visa
- Mastercard
- JCB
- Union Pay
- Contactless/NFC

**Terminal Options:**

```yaml
Countertop Terminal:
  Cost: ‚Ç±15,000 - ‚Ç±25,000 (purchase)
  Rental: ‚Ç±800 - ‚Ç±1,200/month
  Features: EMV chip, swipe, contactless, printer

Mobile Terminal (Bluetooth):
  Cost: ‚Ç±8,000 - ‚Ç±12,000
  Features: Portable, battery-powered, Bluetooth

Smart Terminal (Android):
  Cost: ‚Ç±20,000 - ‚Ç±35,000
  Features: Touch screen, apps, receipt printer
```

**Transaction Fees:**

```yaml
Debit Cards (BancNet): 1.0% - 1.5%
Credit Cards: 2.0% - 2.5%
Contactless: Same as above
Settlement: T+1 to T+3 days
```

**Application Process:**

- Apply through any member bank (BDO, BPI, Metrobank, etc.)
- Or directly through BancNet

**Links:**

- Website: https://www.bancnet.com.ph
- Contact: info@bancnet.com.ph

---

### 2. **PayMaya (Maya Business)**

**Why PayMaya:**

````yaml
‚úÖ Backed Megalink** (Major Card Network)

**Why Megalink:**
```yaml
‚úÖ Major Philippine switching network
‚úÖ Connects to all major banks
‚úÖ Accepts all card types
‚úÖ Reliable infrastructure
‚úÖ Good coverage
````

**Supported Cards:**

- All Philippine debit cards
- Visa, Mastercard
- Express Pay
- JCB, Union Pay

**Terminal Options:**

```yaml
Standard POS Terminal:
  Cost: ‚Ç±12,000 - ‚Ç±20,000
  Rental: ‚Ç±700 - ‚Ç±1,000/month
  Features: EMV chip, magnetic stripe, thermal printer

Wireless Terminal:
  Cost: ‚Ç±15,000 - ‚Ç±25,000
  Features: 3G/4G connectivity, portable

Smart POS:
  Cost: ‚Ç±25,000 - ‚Ç±40,000
  Features: Android OS, touchscreen, apps
```

**Transaction Fees:**

```yaml
Debit: 1.25% - 1.75%
Credit: 2.0% - 2.5%
Minimum: ‚Ç±5 per transaction
Settlement: T+2 days
```

**Application:**

- Through partner banks (UnionBank, RCBC, Security Bank)

**Links:**

- Website: https://www.megalink.com

**Why Xendit:**

```yaml
‚úÖ Regional player (Southeast Asia)
‚úÖ Multiple payment methods
‚úÖ Good for scaling regionally
‚úÖ Advanced features
‚úÖ Strong compliance
```

**Features:**

- Cards (Visa, Mastercard, AMEX, JCB)
- E-wallets (GCash, GrabPay, PayMaya, ShopeePay)
- Direct Bank-Provided Terminals\*\*

Most major Philippine banks offer their own POS terminals:

#### **BDO (Banco de Oro)**

```yaml
Terminal: BDO POS Terminal
Cost: ‚Ç±15,000 or ‚Ç±800/month rental
Fees: 2.0% - 2.5%
Support: BDO Business Banking
Best for: BDO account holders
```

#### **BPI (Bank of the Philippine Islands)**

```yaml
Terminal: BPI POS System
Cost: ‚Ç±12,000 - ‚Ç±18,000
Fees: 1.75% - 2.5%
Support: BPI Merchant Services
Best for: BPI business clients
```

#### **Metrobank**

```yaml
Terminal: Metrobank POS
Cost: ‚Ç±10,000 - ‚Ç±20,000
Fees: 2.0% - 2.5%
Support: Metrobank branch
Best for: Metrobank depositors
```

PayMaya Business (Physical Terminals)\*\*

**Why PayMaya:**

```yaml
‚úÖ Modern, mobile-first
‚úÖ Low-cost entry point
‚úÖ QR code support
‚úÖ Integrated e-wallet acceptance
‚úÖ Fast approval
```

**Terminal Options:**

```yaml
mPOS (Mobile Reader):
  Cost: ‚Ç±2,500 - ‚Ç±5,000 (one-time)
  Connection: Bluetooth to smartphone/tablet
  Cards: Chip, swipe, contactless
  App: Free PayMaya Business app

Smart POS Terminal:
  Cost: ‚Ç±12,000 - ‚Ç±18,000
  Features: Standalone, receipt printer, 4G
```

**Transaction Fees:**

```yaml
Cards: 2.5% - 3.0%
Maya Wallet: 2.0%
QR Payments: 1.5% - 2.0%
Settlement: T+3 days
```

**Best For:**

- Small to medium retailers
- Mobile businesses
- Pop-up stores
- Low-volume merchants

**Links:**

- Website: https://www.maya.ph/business
- Contact: (+63) 2-8845-7788

---

### 5. **GCash for Business**

**Why GCash:**

```yaml
‚úÖ Largest e-wallet in PH
‚úÖ QR code payments
‚úÖ Card reader available
‚úÖ Wide customer adoption
‚úÖ Low fees
```

**Terminal Options:**

````yaml
GCash Card Reader:
  Cost: ‚Ç±1,500 - ‚Ç±3,000
  Connection: Bluetooth/Audio jack
  Cards: Chip aTerminal Hardware Types

### Terminal Categories

**Category 1: Mobile Card Readers (mPOS)**

**Description:** Portable card readers that connect to smartphone/tablet

**Best Use Cases:**
- Food trucks, delivery drivers
- Pop-up stores, bazaars
- Home service businesses
- Sales agents
- Low-volume merchants

**Features:**
```yaml
‚úÖ Portable and lightweight
‚úÖ Battery-powered
‚úÖ Bluetooth connection
‚úÖ Uses merchant's phone/tablet
‚úÖ Low upfront cost
‚úÖ Accept chip, swipe, contactless

‚ùå Requires charged phone/tablet
‚ùå Smaller screen
‚ùå Limited offline capability
````

**Options:**

- PayMaya mPOS: ‚Ç±2,500 - ‚Ç±5,000
- GCash Reader: ‚Ç±1,500 - ‚Ç±3,000
- Generic Bluetooth readers: ‚Ç±1,200 - ‚Ç±2,500

---

**Category 2: Countertop Terminals**

**Description:** Traditional POS terminals for fixed locations

**Best Use Cases:**

- Retail stores with checkout counters
- Restaurants with cashier stations
- Pharmacies
- Convenience stores
- Gas stations

**Features:**

```yaml
‚úÖ Standalone device (no phone needed)
‚úÖ Built-in receipt printer
‚úÖ EMV chip reader
‚úÖ Magnetic stripe
‚úÖ Contactless/NFC
‚úÖ Offline transaction queue
‚úÖ Reliable and proven
‚úÖ Physical keypad for PIN
‚úÖ Dedicated communication line

‚ùå Not portable
‚ùå Higher cost
‚ùå Fixed location
```

**Popular Models:**

```yaml
Ingenico Desk/5000:
  Cost: ‚Ç±15,000 - ‚Ç±22,000
  Features: Color screen, contactless, printer
  Brands using: Most banks

PAX D200:
  Cost: ‚Ç±12,000 - ‚Ç±18,000
  Features: Compact, thermal printer

Verifone VX520:
  Cost: ‚Ç±14,000 - ‚Ç±20,000
  Features: Proven reliability, wide compatibility
```

Integration Approaches

There are **3 main ways** to integrate physical card terminals with your POS system:

---

### **Approach 1: Standalone Terminal (Simplest)** ‚≠ê Recommended to Start

**How it works:**

1. Your POS calculates total amount
2. Cashier manually enters amount on card terminal
3. Customer swipes/inserts card on terminal
4. Terminal processes payment independently
5. Cashier manually records payment in your POS

**Pros:**

```yaml
‚úÖ Easiest to implement (no integration needed)
‚úÖ Lowest cost
‚úÖ No development required
‚úÖ Works immediately
‚úÖ PCI compliance handled by terminal
‚úÖ Terminal is bank/provider certified
```

**Cons:**

```yaml
‚ùå Manual double-entry (amount on terminal, then POS)
‚ùå Room for human error
‚ùå No automatic reconciliation
‚ùå Slower checkout process
‚ùå Two separate receipts (terminal + POS)
```

**Best for:**

- Getting started quickly
- Low transaction volumes
- Limited technical resources
- Testing market acceptance

**Implementation:**

```typescript
// Your POS system
async function processCardPayment(transaction: Transaction) {
  // 1. Display total on your POS screen
  showMessage(`Total: ‚Ç±${transaction.amount.toFixed(2)}`);
  showMessage("Please process payment on card terminal");

  // 2. Wait for cashier confirmation
  const confirmed = await waitForCashierConfirmation();

  if (confirmed) {
    // 3. Record payment in your system
    await db.transactions.update({
      id: transaction.id,
      payment_method: "card",
      payment_status: "completed",
      // Cashier manually enters terminal reference number
      card_terminal_ref: manuallyEnteredRefNumber,
    });

    // 4. Print POS receipt
    await printReceipt(transaction);
  }
}
```

---

### **Approach 2: Serial/USB Integration (Semi-Automated)** ‚≠ê Recommended for Scale

**How it works:**

1. Your POS sends payment command to terminal via cable
2. Terminal receives amount automatically
3. Customer swipes/inserts card
4. Terminal sends response back to POS
5. POS automatically records payment

**Pros:**

```yaml
‚úÖ Automated amount transfer
‚úÖ No double-entry
‚úÖ Faster checkout
‚úÖ Automatic reconciliation
‚úÖ Single receipt (POS prints combined)
‚úÖ Professional experience
‚úÖ Error reduction
```

**Cons:**

```yaml
‚ùå Requires terminal with serial/USB port
‚ùå Development effort needed
‚ùå Need terminal SDK/protocol documentation
‚ùå Physical cable connection
‚ùå More complex troubleshooting
```

**Best for:**

- Medium to high volume
- Multiple terminals
- Professional retail operations
- When accuracy is critical

**Communication Protocol:**

Most terminals use **serial communication** (RS-232) or **USB**:

```typescript
// Example: Communicating with PAX terminal

import SerialPort from "serialport";

class CardTerminalService {
  private port: SerialPort;

  constructor(portPath: string = "/dev/ttyUSB0") {
    this.port = new SerialPort(portPath, {
      baudRate: 115200,
      dataBits: 8,
      parity: "none",
      stopBits: 1,
    });
  }

  // Send payment request to terminal
  async requestPayment(amount: number): Promise<PaymentResult> {
    return new Promise((resolve, reject) => {
      // Build payment command (varies by terminal)
      const command = this.buildPaymentCommand(amount);

      // Send to terminal
      this.port.write(command);

      // Wait for response
      this.port.once("data", (data: Buffer) => {
        const result = this.parseTerminalResponse(data);

        if (result.approved) {
          resolve({
            status: "approved",
            amount: amount,
            cardType: result.cardType,
            last4Digits: result.last4,
            authCode: result.authCode,
            referenceNumber: result.refNumber,
            terminalId: result.terminalId,
            timestamp: new Date(),
          });
        } else {
          reject(new Error(result.errorMessage));
        }
      });

      // Timeout after 60 seconds
      setTimeout(() => {
        reject(new Error("Payment timeout"));
      }, 60000);
    });
  }

  // Build command based on terminal protocol
  private buildPaymentCommand(amount: number): Buffer {
    // Example for PAX terminal (varies by brand)
    // Format: STX|CMD|AMOUNT|ETX
    const amountInCents = Math.round(amount * 100);
    const command = `\x02T01${amountInCents.toString().padStart(12, "0")}\x03`;
    return Buffer.from(command, "ascii");
  }

  // Parse terminal response
  private parseTerminalResponse(data: Buffer): TerminalResponse {
    // Parse based on terminal protocol
    const response = data.toString("ascii");

    // Example parsing (format varies by terminal)
    return {
      approved: response.includes("APPROVED"),
      cardType: this.extractCardType(response),
      last4: this.extractLast4(response),
      authCode: this.extractAuthCode(response),
      refNumber: this.extractRefNumber(response),
      terminalId: this.extractTerminalId(response),
      errorMessage: this.extractError(response),
    };
  }

  // Cancel ongoing transaction
  async cancelTransaction(): Promise<void> {
    const cancelCommand = Buffer.from("\x02C01\x03", "ascii");
    this.port.write(cancelCommand);
  }
}

// Usage in your POS
async function processCardPayment(transaction: Transaction) {
  const terminal = new CardTerminalService("/dev/ttyUSB0");

  try {
    // Show "Processing..." on POS
    showProcessingScreen();

    // Send amount to terminal
    const result = await terminal.requestPayment(transaction.amount);

    // Save payment details
    await db.transactions.update({
      id: transaction.id,
      payment_method: "card",
      payment_status: "completed",
      card_type: result.cardType,
      card_last4: result.last4Digits,
      auth_code: result.authCode,
      terminal_ref: result.referenceNumber,
      terminal_id: result.terminalId,
    });

    // Print combined receipt
    await printReceipt({
      ...transaction,
      cardPaymentDetails: result,
    });

    showSuccess("Payment approved!");
  } catch (error) {
    showError(`Payment failed: ${error.message}`);
    await terminal.cancelTransaction();
  }
}
```

**Common Terminal Protocols:**

- PAX: Proprietary protocol (contact PAX for SDK)
- Ingenico: Telium protocol
- Verifone: VHQ/VIPA protocol
- Generic: ISO 8583 messages

**Getting Terminal SDK:**

1. Contact terminal manufacturer
2. Request developer documentation
3. Sign NDA if required
4. Get SDK/protocol specs
5. Request test terminal

---

### **Approach 3: API Integration (Cloud-Connected)** üöÄ Future-Proof

**How it works:**

1. Your POS calls cloud API with payment amount
2. API communicates with terminal via internet
3. Customer swipes card on terminal
4. Terminal sends result to cloud
5. Cloud API notifies your POS
6. POS records payment automatically

**Pros:**

```yaml
‚úÖ No physical connection needed
‚úÖ Works with WiFi/4G terminals
‚úÖ Remote terminal management
‚úÖ Real-time monitoring
‚úÖ Centralized reporting
‚úÖ Easy multi-location setup
‚úÖ Automatic updates
```

**Cons:**

```yaml
‚ùå Requires internet connection
‚ùå More expensive terminals
‚ùå Dependency on cloud service
‚ùå Monthly API fees possible
‚ùå Latency issues with poor connection
```

**Best for:**

- Multi-location businesses
- Cloud-based POS systems
- Modern smart terminals
- Managed services model

**Implementation Example:**

```typescript
// Using Smart Terminal API (e.g., PAX Store or similar)

class CloudTerminalService {
  private apiKey: string;
  private baseUrl: string;

  constructor() {
    this.apiKey = process.env.TERMINAL_API_KEY;
    this.baseUrl = "https://terminal-api.provider.com";
  }

  // Initiate payment on terminal
  async initiatePayment(
    terminalId: string,
    amount: number,
    transactionRef: string
  ): Promise<string> {
    const response = await fetch(`${this.baseUrl}/payments`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${this.apiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        terminal_id: terminalId,
        amount: amount * 100, // centavos
        currency: "PHP",
        reference: transactionRef,
        callback_url: "https://yourpos.com/webhooks/terminal",
      }),
    });

    const data = await response.json();
    return data.payment_id;
  }

  // Poll for payment status
  async getPaymentStatus(paymentId: string): Promise<PaymentStatus> {
    const response = await fetch(`${this.baseUrl}/payments/${paymentId}`, {
      headers: {
        Authorization: `Bearer ${this.apiKey}`,
      },
    });

    return await response.json();
  }

  // Handle webhook from terminal API
  async handleWebhook(payload: any): Promise<void> {
    // Verify webhook signature
    const isValid = this.verifyWebhook(payload);
    if (!isValid) throw new Error("Invalid webhook");

    // Process payment result
    if (payload.status === "approved") {
      await this.recordPayment({
        transactionRef: payload.reference,
        amount: payload.amount / 100,
        cardType: payload.card_type,
        last4: payload.card_last4,
        authCode: payload.auth_code,
        terminalId: payload.terminal_id,
      });
    }
  }
}

// Usage
async function processCardPayment(transaction: Transaction) {
  const terminalService = new CloudTerminalService();

  try {
    // Send payment request to terminal
    const paymentId = await terminalService.initiatePayment(
      "TERMINAL-001",
      transaction.amount,
      transaction.invoice_number
    );

    // Show waiting screen
    showMessage("Waiting for customer to pay on terminal...");

    // Poll for status (or wait for webhook)
    const result = await terminalService.pollUntilComplete(paymentId);

    if (result.status === "approved") {
      // Record payment
      await db.transactions.update({
        id: transaction.id,
        payment_method: "card",
        payment_status: "completed",
        card_details: result,
      });

      showSuccess("Payment approved!");
      await printReceipt(transaction);
    }
  } catch (error) {
    showError(`Payment failed: ${error.message}`);
  }
}
```

---

### **Comparison Matrix**

| Feature           | Standalone   | Serial/USB      | API Integration           |
| ----------------- | ------------ | --------------- | ------------------------- |
| Setup Complexity  | ‚≠ê Easy      | ‚≠ê‚≠ê‚≠ê Medium   | ‚≠ê‚≠ê‚≠ê‚≠ê Complex          |
| Development Time  | None         | 2-4 weeks       | 1-2 weeks                 |
| Hardware Cost     | ‚Ç±12k-25k     | ‚Ç±12k-25k        | ‚Ç±20k-35k                  |
| Monthly Fees      | ‚Ç±0           | ‚Ç±0              | ‚Ç±0-‚Ç±1,000                 |
| Automation        | Manual       | Automated       | Fully Automated           |
| Speed             | Slow         | Fast            | Fast                      |
| Accuracy          | Low          | High            | High                      |
| Internet Required | No           | No              | Yes                       |
| Remote Management | No           | No              | Yes                       |
| Best For          | Starting out | Most businesses | Enterprise/Multi-location |

---

### **Recommended Implementation Path:**

**Phase 1:** Start with **Standalone** (Week 1)

- Get terminal from bank/provider
- Use manually
- Test customer acceptance
- Learn terminal operations

**Phase 2:** Upgrade to **Serial/USB** (Month 2-3)

- Once volume increases (>50 transactions/day)
- Request terminal SDK from provider
- Develop integration
- Test thoroughly
- Deploy

**Phase 3:** Consider **API** (Month 6-12)

- When expanding to multiple locations
- When launching cloud POS
- When you need centralized management // 4. Log transaction
  await this.logTransaction(result, metadata);
      return result;
  }
  // Handle webhooks for async updates
  async handleWebhook(payload: any, signature: string) {
  // Verify webhook signature
  const isValid = this.verifyWebhookSignature(payload, signature);
  if (!isValid) {
  throw new Error('Invalid webhook signature');
  }
      // Process event
      const event = payload.data;

      switch (event.attributes.type) {
        case 'payment.paid':
          await this.handlePaymentSuccess(event);
          break;
        case 'payment.failed':
          await this.handlePaymentFailure(event);
          break;
        case 'payment.refunded':
          await this.handleRefund(event);
          break;
      }
  }
  // Process refund
  async refundPayment(paymentId: string, amount: number, reason: string) {
  try {
  const refund = await this.paymongo.refunds.create({
  data: {
  attributes: {
  amount: amount \* 100,
  payment_id: paymentId,
  reason: reason
  }
  }
  });
        return refund;
      } catch (error) {
        throw new Error(`Refund failed: ${error.message}`);
      }
  }
  }

interface CardDetails {
number: string;
expMonth: number;
expYear: number;
cvc: string;
holderName: string;
email: string;
}

````

---

### Frontend Integration (React/Next.js)

```typescript
// Card payment component
import { useState } from 'react';
import { CardElement, useStripe, useElements } from '@stripe/react-stripe-js';

export function CardPaymentForm({ amount, onSuccess, onError }) {
  const [processing, setProcessing] = useState(false);
  const stripe = useStripe();
  const elements = useElements();

  const handleSubmit = async (e) => {
    e.preventDefault();

    if (!stripe || !elements) return;

    setProcessing(true);

    try {
      // 1. Create payment intent on server
      const { clientSecret } = await fetch('/api/create-payment-intent', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ amount })
      }).then(r => r.json());

      // 2. Confirm payment with Stripe
      const result = await stripe.confirmCardPayment(clientSecret, {
        payment_method: {
          card: elements.getElement(CardElement),
          billing_details: {
            name: 'Customer Name'
          }
        }
      });

      if (result.error) {
        onError(result.error.message);
      } else {
        onSuccess(result.paymentIntent);
      }
    } catch (error) {
      onError(error.message);
    } finally {
      setProcessing(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <CardElement
        options={{
          style: {
            base: {
              fontSize: '16px',
              color: '#424770',
              '::placeholder': {
                color: '#aab7c4',
              },
            },
            invalid: {
              color: '#9e2146',
            },
          },
        }}
      />
      <button type="submit" disabled={processing || !stripe}>
        {processing ? 'Processing...' : `Pay ‚Ç±${amount.toFixed(2)}`}
      </button>
    </form>
  );
}
````

---

## üîí PCI DSS Compliance

### What is PCI DSS?

**Payment Card Industry Data Security Standard**

- Required for handling card data
- Protects cardholder information
- Reduces fraud risk
- Mandatory for merchants

---

### Compliance Levels

```yaml
Level 1: 6M+ transactions/year
  - Full audit required
  - Quarterly scans
  - High complexity

Level 2: 1M-6M transactions/year
  - Self-assessment questionnaire
  - Quarterly scans

Level 3: 20K-1M transactions/year
  - Self-assessment questionnaire
  - Quarterly scans

Level 4: <20K transactions/year (Most SMEs)
  - Self-assessment questionnaire
  - Annual scan
  - Lowest cost
```

Most of your customers will be **Level 4**.

---

### Easiest Compliance Approach: **Don't Store Card Data**

```typescript
// ‚úÖ GOOD: Token-based approach
// Card data goes directly to payment gateway
// Your server never sees card numbers

// Payment gateway returns token
const token = await paymentGateway.createToken(cardDetails);

// You only store the token
await db.transactions.create({
  amount: 100,
  payment_token: token.id, // Safe to store
  payment_method: "card",
  last4: token.card.last4, // Only last 4 digits
});
```

```typescript
// ‚ùå BAD: Storing card data
// NEVER do this - requires full PCI compliance
await db.transactions.create({
  card_number: "4111111111111111", // NEVER!
  cvv: "123", // NEVER!
  exp_date: "12/25", // NEVER!
});
```

---

### Recommended Approach

**Use Payment Gateway's Hosted Forms:**

```typescript
// PayMongo hosted payment page
const checkout = await paymongo.checkoutSession.create({
  amount: 10000,
  description: "Invoice payment",
  success_url: "https://yoursite.com/success",
  cancel_url: "https://yoursite.com/cancel",
});

// Redirect customer to PayMongo's secure page
window.location.href = checkout.checkout_url;

// PayMongo handles:
// ‚úÖ Card input form
// ‚úÖ Validation
// ‚úÖ 3D Secure
// ‚úÖ PCI compliance
// ‚úÖ Security

// You get webhook notification when complete
```

**Benefits:**

- Zero PCI compliance burden on you
- Payment gateway handles all security
- Still branded experience
- Lower risk

---

### If You Must Process Cards Directly

**Requirements:**

1. **SSL/TLS Certificate** - HTTPS only
2. **Secure Network** - Firewall, VPN
3. **No Card Storage** - Use tokenization
4. **Access Control** - Limit who can see data
5. **Monitoring** - Log all access
6. **Testing** - Regular security audits
7. **Documentation** - All policies documented

**Annual Costs:**

- PCI DSS scanning: ‚Ç±20,000 - ‚Ç±50,000/year
- Security audit: ‚Ç±50,000 - ‚Ç±200,000/year
- Compliance tools: ‚Ç±30,000 - ‚Ç±100,000/year

**Not recommended for most SMEs.**

---

## üí∞ Cost Analysis

### Payment Processing Fees Comparison

```yaml
Payment Method Costs (Typical):

Credit/Debit Cards:
  Online: 3.5% + ‚Ç±15
  In-person: 2.0% - 2.5%

E-wallets (GCash, PayMaya):
  Rate: 2.0% - 2.5%

Bank Transfer:
  Rate: 1.0% - 2.0%
  Flat: ‚Ç±10 - ‚Ç±25

Over-the-Counter:
  Flat: ‚Ç±15 - ‚Ç±25

Cash:
  Rate: 0% (but handling costs)
```

### Example: ‚Ç±10,000 Transaction

```yaml
Cash: ‚Ç±10,000 revenue, ‚Ç±0 fee = ‚Ç±10,000 net

Card (online): ‚Ç±10,000 - (‚Ç±10,000 √ó 3.5% + ‚Ç±15)
  = ‚Ç±10,000 - ‚Ç±365
  = ‚Ç±9,635 net

Card (in-person): ‚Ç±10,000 - (‚Ç±10,000 √ó 2.5%)
  = ‚Ç±10,000 - ‚Ç±250
  = ‚Ç±9,750 net

GCash: ‚Ç±10,000 - (‚Ç±10,000 √ó 2.5%)
  = ‚Ç±9,750 net

Bank Transfer: ‚Ç±10,000 - ‚Ç±25
  = ‚Ç±9,975 net
```

---

## üöÄ Implementation Roadmap

### Phase 1: Basic Integration (Month 1)

**MVP Features:**

- [ ] Sign up with PayMongo
- [ ] Basic card payment API integration
- [ ] Payment recording in database
- [ ] Receipt generation with payment method
- [ ] Test mode implementation

**Deliverables:**

- Card payment working in test mode
- Backend API endpoints
- Frontend payment form
- Transaction logging

---

### Phase 2: Production Ready (Month 2)

**Features:**

- [ ] Live mode deployment
- [ ] Webhook handling for async updates
- [ ] Refund functionality
- [ ] Failed payment handling
- [ ] 3D Secure support
- [ ] Error handling and retries

**Deliverables:**

- Production credentials
- Webhook endpoints secured
- Full payment flow tested
- Documentation completed

---

### Phase 3: Enhanced Features (Month 3)

**Features:**

- [ ] Multiple payment methods (GCash, bank transfer)
- [ ] Payment splitting (cash + card)
- [ ] Installment plans
- [ ] Recurring billing (subscriptions)
- [ ] Digital receipts via email/SMS

---

### Phase 4: Physical Terminals (Month 4)

**Features:**

- [ ] Physical card reader integration
- [ ] Offline payment queue
- [ ] Sync when back online
- [ ] Terminal management
- [ ] Multi-terminal support

---

## üìã Merchant Application Requirements

### Documents Needed

**For Sole Proprietors (DTI):**

- ‚úÖ DTI Business Registration
- ‚úÖ BIR Certificate of Registration (Form 2303)
- ‚úÖ Mayor's Permit
- ‚úÖ Valid Government ID (owner)
- ‚úÖ Bank account details
- ‚úÖ Business proof (photos, website)

**For Corporations (SEC):**

- ‚úÖ SEC Registration
- ‚úÖ Articles of Incorporation
- ‚úÖ BIR Form 2303
- ‚úÖ Mayor's Permit
- ‚úÖ Valid IDs (officers)
- ‚úÖ Corporate bank account
- ‚úÖ Board resolution

---

### Application Process

```yaml
Step 1: Choose Payment Gateway
  Duration: 1 day

Step 2: Submit Application
  Duration: 1-3 days

Step 3: Document Verification
  Duration: 3-7 days

Step 4: Underwriting & Approval
  Duration: 5-10 days

Step 5: Account Setup & Testing
  Duration: 2-5 days

Total Time: 2-4 weeks
```

**Tips for Faster Approval:**

- Complete all documents upfront
- Have clear business description
- Show existing business presence
- Provide business website/social media
- Have bank account ready

---

## üîß Testing & Sandbox

### PayMongo Test Cards

```yaml
Success:
  Card: 4343 4343 4343 4345
  Exp: Any future date
  CVC: Any 3 digits

Insufficient Funds:
  Card: 4571 7360 0000 0008

Invalid CVV:
  Card: 4571 7360 0000 0016

Expired Card:
  Card: 4571 7360 0000 0024

3D Secure Required:
  Card: 4120 0000 0000 0007
```

### Test Workflow

```typescript
// 1. Development (Local)
const paymongo = new PayMongo(process.env.PAYMONGO_TEST_SECRET);

// 2. Use test cards
const payment = await paymongo.createPayment({
  card_number: "4343434343434345",
  exp_month: 12,
  exp_year: 2027,
  cvc: "123",
});

// 3. Verify webhook locally (ngrok)
// Use ngrok to expose localhost
// Register webhook: https://your-ngrok-url.com/webhooks/paymongo

// 4. Test all scenarios
// - Successful payment
// - Failed payment
// - Refund
// - 3D Secure flow
```

---

## üìä Reporting & Reconciliation

### Daily Reconciliation

```typescript
// Match POS transactions with gateway settlements

async function reconcilePayments(date: Date) {
  // 1. Get POS transactions
  const posTransactions = await db.transactions.findMany({
    where: {
      date: date,
      payment_method: "card",
    },
  });

  // 2. Get gateway transactions
  const gatewayTransactions = await paymongo.payments.list({
    created_after: startOfDay(date),
    created_before: endOfDay(date),
  });

  // 3. Match by payment ID
  const matched = [];
  const unmatched = [];

  for (const posTransaction of posTransactions) {
    const gatewayMatch = gatewayTransactions.find(
      (gt) => gt.id === posTransaction.payment_id
    );

    if (gatewayMatch) {
      matched.push({ pos: posTransaction, gateway: gatewayMatch });
    } else {
      unmatched.push(posTransaction);
    }
  }

  // 4. Generate reconciliation report
  return {
    date,
    matched: matched.length,
    unmatched: unmatched.length,
    totalAmount: sum(matched.map((m) => m.pos.amount)),
    discrepancies: unmatched,
  };
}
```

---

## üí° Best Practices

### Security

```typescript
// ‚úÖ DO: Use environment variables
const apiKey = process.env.PAYMONGO_SECRET_KEY;

// ‚ùå DON'T: Hardcode keys
const apiKey = "sk_test_1234567890"; // NEVER!

// ‚úÖ DO: Validate webhooks
const isValid = verifyWebhookSignature(payload, signature);

// ‚ùå DON'T: Trust webhook data blindly

// ‚úÖ DO: Use HTTPS only
if (req.protocol !== "https") {
  return res.status(403).send("HTTPS required");
}

// ‚úÖ DO: Implement idempotency
await createPayment({
  idempotency_key: `${tenantId}-${invoiceNumber}-${Date.now()}`,
});
```

### User Experience

```typescript
// ‚úÖ DO: Show clear payment status
<PaymentStatus
  status={payment.status}
  message="Payment processing..."
  showProgress={true}
/>;

// ‚úÖ DO: Handle errors gracefully
if (paymentError) {
  showUserFriendlyMessage(paymentError);
  offerRetryOption();
}

// ‚úÖ DO: Provide receipt immediately
await generateReceipt({
  payment_method: "card",
  card_last4: "4345",
  transaction_id: payment.id,
});

// ‚úÖ DO: Send confirmation
await sendEmailReceipt(customer.email, receipt);
```

---

## üìû Support Contacts

### PayMongo

- Email: support@paymongo.com
- Phone: +63 2 8808 0277
- Chat: dashboard.paymongo.com

### PayMaya

- Email: support@maya.ph
- Phone: (+63) 2-8845-7788
- Support hours: 8 AM - 8 PM

### Xendit

- Email: support@xendit.co
- Support: 24/7

---

## ‚úÖ Checklist

### Before Going Live

- [ ] Payment gateway account approved
- [ ] API keys secured in environment variables
- [ ] Test mode thoroughly tested
- [ ] Production mode tested with real cards
- [ ] Webhook endpoints secured and tested
- [ ] SSL certificate installed
- [ ] Error handling implemented
- [ ] Refund process tested
- [ ] Reconciliation process set up
- [ ] Customer support trained
- [ ] Terms & conditions updated
- [ ] Privacy policy updated (card data handling)
- [ ] PCI compliance questionnaire completed
- [ ] Payment receipt templates updated
- [ ] BIR OR/SI includes payment method

---

## üéØ Recommendation for Your POS System

**Best Approach:**

1. **Start with PayMongo API** (Online payments)

   - Best developer experience
   - Lowest fees for online
   - Fast approval

2. **Add Physical Card Reader** (In-person)

   - PayMaya mPOS (‚Ç±2,500)
   - or GCash Reader (‚Ç±1,500)
   - Lower fees (2.5%)

3. **Use Hosted Payment Pages** (PCI compliance)

   - Zero compliance burden
   - Gateway handles security
   - Quick implementation

4. **Offer Multiple Options**
   - Cash (0% fee)
   - Cards (PayMongo)
   - GCash (direct integration)
   - Bank transfer (Instapay/Pesonet)

**Cost for merchant:**

- Add ‚Ç±500/month to subscription for payment processing features
- or Include in Professional/Enterprise plans
- Merchants pay gateway fees directly to provider

---

**Ready to accept cards and boost your sales!** üí≥üöÄ
